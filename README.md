# Текстовый редактор с компонентами компилятора

Проект представляет собой текстовый редактор с графическим интерфейсом, разработанный на Python с использованием PyQt6. В рамках курсовой работы по дисциплине "Теория формальных языков и компиляторов" редактор дополнен компонентами компилятора, такими как лексический и синтаксический анализаторы, обработка ошибок, создание внутреннего представления и работа с регулярными выражениями.

## Основные функции

- **Многодокументный интерфейс**: Работа с несколькими вкладками одновременно.
- **Нумерация строк**: Отображение номеров строк в области редактирования.
- **Изменение размера шрифта**: Увеличение и уменьшение размера шрифта с помощью горячих клавиш или кнопок.
- **Редактирование текста**: Поддержка стандартных операций (вырезать, копировать, вставить, отменить, повторить).
- **Сохранение и открытие файлов**: Работа с текстовыми файлами.
- **Проверка несохраненных изменений**: Предупреждение о несохраненных изменениях при закрытии вкладки или приложения.
- **Горячие клавиши**: Удобные сочетания клавиш для быстрого доступа к функциям.
- **Темная и светлая тема**: Автоматическое переключение иконок в зависимости от системной темы.

## Установка и запуск

1. Убедитесь, что у вас установлен Python 3.8 или выше.
2. Установите необходимые зависимости:

   ```bash
   pip install PyQt6
   ```
3. Запустите приложение:

   ```bash
   python interf.py
   ```

## Выполненные лабораторные работы

### Лабораторная работа №2 - Лексический анализатор (сканер)

**Реализация**: `scanner.py`

В рамках этой работы был разработан лексический анализатор для JavaScript, который выполняет:
- Разбиение входного текста на лексемы (токены) с помощью регулярных выражений
- Классификацию токенов по типам: ключевые слова, идентификаторы, числа, строки, операторы и т.д.
- Определение позиции каждого токена (строка, столбец)
- Обнаружение лексических ошибок (например, незакрытые кавычки, недопустимые символы)

Класс `JSScanner` реализует диаграмму состояний сканера, представленную в виде ASCII-арта внутри кода. Результаты сканирования отображаются в виде таблицы со столбцами: код лексемы, тип, значение и позиция.

### Лабораторная работа №3 - Синтаксический анализатор (парсер)

**Реализация**: `parser.py`

В этой работе разработан синтаксический анализатор для JavaScript с фокусом на ассоциативные массивы, который:
- Реализует конечный автомат для проверки синтаксических конструкций
- Обнаруживает и выводит синтаксические ошибки
- Интегрирован с лексическим анализатором (использует токены, сформированные сканером)

Парсер основан на автоматной грамматике, которая описывает объявление ассоциативных массивов. Граф конечного автомата реализован в виде набора состояний и переходов между ними. Результат анализа выводится в виде сообщений об обнаруженных ошибках или сообщения об отсутствии ошибок.

### Лабораторная работа №4 - Нейтрализация ошибок (метод Айронса)

**Реализация**: `parser.py` (интегрировано с синтаксическим анализатором)

В этой работе реализован метод Айронса для нейтрализации синтаксических ошибок:
- Возможность продолжения анализа после обнаружения ошибки
- Восстановление после ошибки путем пропуска некорректных токенов или вставки пропущенных
- Логирование действий по восстановлению

Метод Айронса позволяет не только обнаруживать ошибки, но и продолжать анализ, что особенно полезно при наличии нескольких ошибок в коде. Это достигается путем перехода к ближайшему "синхронизирующему" токену, от которого можно продолжить анализ.

### Лабораторная работа №5 - Включение семантики и внутренняя форма представления

**Реализация**: `expression_parser_with_quads.py`

#### Постановка задачи
Разработать алгоритм для разбора арифметических выражений и формирования их внутреннего представления в виде тетрад (четверок). Реализовать семантический анализатор, который преобразует синтаксически корректные конструкции в промежуточное представление для последующей обработки.

#### Вариант задания
Разработать синтаксический анализатор арифметических выражений методом рекурсивного спуска с формированием четверок (тетрад) вида (операция, аргумент1, аргумент2, результат).

Грамматика арифметических выражений:
```
E → T A
A → + T A | - T A | ε
T → O B
B → * O B | / O B | ε
O → - O | идентификатор | (E)
```

Где:
- E - выражение
- T - терм
- A - продолжение выражения
- B - продолжение терма
- O - операнд

#### Примеры верных строк
- `a + b`
- `a + b * c`
- `(a + b) * c`
- `a - b / c`
- `-a + b`
- `a * (b + c)`
- `a * b - c / d`

#### Тестовые примеры

1. Пример: `a + b * c`
   
   Тетрады:
   ```
   (*, b, c, t1)
   (+, a, t1, t2)
   ```

2. Пример: `(a + b) * c`
   
   Тетрады:
   ```
   (+, a, b, t1)
   (*, t1, c, t2)
   ```

3. Пример: `-a + b`
   
   Тетрады:
   ```
   (uminus, a, _, t1)
   (+, t1, b, t2)
   ```

4. Пример: `a * b - c / d`
   
   Тетрады:
   ```
   (*, a, b, t1)
   (/, c, d, t2)
   (-, t1, t2, t3)
   ```

Алгоритм реализован с учетом приоритета операций и правильной ассоциативности. Промежуточные результаты сохраняются во временных переменных (t1, t2, ...), которые затем используются для построения более сложных выражений. Унарный минус обрабатывается специальным образом с использованием операции "uminus" и символа подчеркивания "_" в качестве пустого аргумента.

### Лабораторная работа №6 - Реализация алгоритма поиска с помощью регулярных выражений

**Реализация**: `regex_search.py`, `regex_search_dialog.py`

В данной лабораторной работе реализован алгоритм поиска в тексте с использованием регулярных выражений с возможностью нахождения и валидации трех различных типов подстрок:

#### Задача 1: Поиск номеров СНИЛС
Реализован поиск номеров СНИЛС в формате XXX-XXX-XXX XX с проверкой контрольной суммы.

**Регулярное выражение**: `\b\d{3}-\d{3}-\d{3}\s\d{2}\b`

**Примеры поиска**:
- `123-456-789 00` - найдено в строке 2, позиция 1
- `123-456-789 01` - найдено в строке 3, позиция 1
- `123-45-6789 00` - не соответствует шаблону
- `12345678900` - не соответствует шаблону

**Проверка контрольной суммы**:
Для проверки контрольной суммы СНИЛС реализован алгоритм:
1. Извлекаются цифры из номера СНИЛС
2. Для каждой цифры с 1-й по 9-ю вычисляется произведение на вес (9 - номер позиции)
3. Вычисляется сумма произведений по модулю 101
4. Если результат равен 100, контрольная сумма равна 0
5. Иначе контрольная сумма равна остатку от деления

#### Задача 2: Поиск номеров карт платежной системы Мир
Реализован поиск номеров карт Мир, которые начинаются с цифр 2200-2204 и содержат 16 цифр, с проверкой по алгоритму Луна.

**Регулярное выражение**: `\b220[0-4]\d{12}\b`

**Примеры поиска**:
- `2200123456789012` - найдено в строке 8, позиция 1
- `2204123456789012` - найдено в строке 12, позиция 1
- `2205123456789012` - не соответствует шаблону (неверный префикс)
- `220012345678901` - не соответствует шаблону (недостаточно цифр)

**Валидация номера карты**:
Для проверки номера карты используется алгоритм Луна:
1. Цифры нумеруются с конца
2. Цифры на нечетных позициях суммируются напрямую
3. Цифры на четных позициях умножаются на 2, если результат превышает 9, из него вычитается 9
4. Все полученные значения суммируются
5. Если сумма кратна 10, номер карты валиден

#### Задача 3: Поиск символов химических элементов
Реализован поиск символов химических элементов из таблицы Менделеева.

**Регулярное выражение**: 
```
\b(?:H|He|Li|Be|B|C|N|O|F|Ne|Na|Mg|Al|Si|P|S|Cl|Ar|K|Ca|Sc|Ti|V|Cr|Mn|Fe|Co|Ni|Cu|Zn|Ga|Ge|As|Se|Br|Kr|Rb|Sr|Y|Zr|Nb|Mo|Tc|Ru|Rh|Pd|Ag|Cd|In|Sn|Sb|Te|I|Xe|Cs|Ba|La|Ce|Pr|Nd|Pm|Sm|Eu|Gd|Tb|Dy|Ho|Er|Tm|Yb|Lu|Hf|Ta|W|Re|Os|Ir|Pt|Au|Hg|Tl|Pb|Bi|Po|At|Rn|Fr|Ra|Ac|Th|Pa|U|Np|Pu|Am|Cm|Bk|Cf|Es|Fm|Md|No|Lr|Rf|Db|Sg|Bh|Hs|Mt|Ds|Rg|Cn|Nh|Fl|Mc|Lv|Ts|Og)\b
```

**Примеры поиска**:
- `H` - найдено в строке 18, позиция 1
- `He` - найдено в строке 19, позиция 1
- `Fe` - найдено в строке 23, позиция 1
- `Au` - найдено в строке 24, позиция 1
- `H2O` - не соответствует шаблону (молекула, не элемент)
- `NaCl` - не соответствует шаблону (соединение, не элемент)

**Особенности реализации**:
Для всех найденных совпадений вычисляется и отображается точное положение в тексте:
- Номер строки
- Номер колонки (позиция с начала строки)
- Индекс начала и конца в общем тексте

Поиск осуществляется с помощью встроенного модуля `re` в Python с использованием метода `re.finditer()`, который позволяет находить все совпадения в тексте и получать их позиции.

## Структура проекта

- `interf.py` - Основной файл приложения с пользовательским интерфейсом
- `ui_interf.py` - Дополнительный UI-код 
- `scanner.py` - Лексический анализатор (Лаб. работа №2)
- `parser.py` - Синтаксический анализатор с нейтрализацией ошибок (Лаб. работы №3 и №4)
- `expression_parser_with_quads.py` - Семантический анализатор и формирование тетрад (Лаб. работа №5)
- `regex_search.py` - Алгоритмы поиска по регулярным выражениям (Лаб. работа №6)
- `regex_search_dialog.py` - Диалоговое окно для поиска по регулярным выражениям (Лаб. работа №6)
- `simple_text_edit.py` - Расширенный редактор кода с подсветкой ошибок